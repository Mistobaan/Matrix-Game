<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Matrix-Game Websocket Tester</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2rem;
      background: #0f172a;
      color: #e2e8f0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    fieldset {
      border: 1px solid #334155;
      padding: 1rem;
      margin-bottom: 1rem;
      width: min(100%, 720px);
      background: rgba(15, 23, 42, 0.75);
    }
    legend { padding: 0 0.5rem; }
    label { display: block; margin-top: 0.5rem; }
    input, select, button { margin-top: 0.25rem; padding: 0.4rem 0.6rem; }
    #log { height: 220px; overflow: auto; background: #1e293b; padding: 1rem; font-size: 0.9rem; }
    .controls { display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap; }
    #imagePreview { margin-top: 0.75rem; max-width: 320px; border: 1px solid #334155; display: none; }
    .gallery { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.75rem; }
    .gallery button { border: 1px solid #334155; background: #0f172a; padding: 0; cursor: pointer; }
    .gallery button.active { border-color: #22d3ee; box-shadow: 0 0 0 2px rgba(34, 211, 238, 0.35); }
    .gallery img { display: block; width: 96px; height: 54px; object-fit: cover; }
    #stream { display: flex; flex-direction: column; align-items: center; text-align: center; gap: 0.5rem; }
    .control-hints { font-size: 0.95rem; line-height: 1.45; color: #bae6fd; max-width: 640px; }
    .control-hints div + div { margin-top: 0.35rem; }
    #streamFrame { width: 640px; max-width: 100%; border: 1px solid #22d3ee; background: #000; display: none; margin: 0.5rem auto 0; }
    #streamMeta { font-size: 0.85rem; color: #94a3b8; margin-top: 0.25rem; }
  </style>
</head>
<body>
  <h1>Matrix-Game Streaming Sandbox</h1>

  <fieldset id="connection">
    <legend>Connection</legend>
    <label>Host <input id="host" value="209.20.158.230"></label>
    <label>Port <input id="port" value="8765"></label>
    <label>Mode
      <select id="mode">
        <option value="universal">universal</option>
        <option value="gta_drive">gta_drive</option>
        <option value="templerun">templerun</option>
      </select>
    </label>
    <div class="controls">
      <button id="connect">Connect</button>
      <button id="setup" disabled>Start Session</button>
      <button id="generate" disabled>Generate</button>
      <button id="reset" disabled>Reset Buffer</button>
    </div>
  </fieldset>

  <fieldset id="reference">
    <legend>Reference Frame</legend>
    <label>Reference image path (server visible)
      <input id="image" placeholder="Matrix-Game-2/demo_images/universal/0000.png">
    </label>
    <div id="imageGallery" class="gallery"></div>
    <img id="imagePreview" alt="Reference preview">
  </fieldset>

  <fieldset id="stream">
    <legend>Live Stream</legend>
    <div class="control-hints">
      <div>PRESS [I, K, J, L, U] FOR CAMERA TRANSFORM<br>(I: up, K: down, J: left, L: right, U: no move)</div>
      <div>PRESS [W, S, A, D, Q] FOR MOVEMENT<br>(W: forward, S: back, A: left, D: right, Q: no move)</div>
    </div>
    <img id="streamFrame" alt="Generated frame">
    <div id="streamMeta"></div>
  </fieldset>

  <fieldset>
    <legend>Status</legend>
    <div id="log"></div>
  </fieldset>

  <script>
    const KEY_MAP = {
      universal: {
        KeyW: "forward",
        KeyS: "back",
        KeyA: "left",
        KeyD: "right"
      },
      gta_drive: {
        KeyW: "forward",
        KeyS: "back"
      },
      templerun: {
        KeyQ: "nomove",
        KeyW: "jump",
        KeyS: "slide",
        KeyA: "leftside",
        KeyD: "rightside",
        ArrowLeft: "turnleft",
        ArrowRight: "turnright",
        KeyZ: "turnleft",
        KeyC: "turnright",
        Space: "jump"
      }
    };

    const MOVEMENT_KEYS = {
      KeyW: "forward",
      KeyS: "back",
      KeyA: "left",
      KeyD: "right",
      KeyQ: "nomove",
    };

    const CAMERA_KEYS = {
      KeyI: "up",
      KeyK: "down",
      KeyJ: "left",
      KeyL: "right",
      KeyU: "nomove",
    };

    const MODE_MOUSE = { universal: true, gta_drive: true, templerun: false };
    const MAX_EVENT_QUEUE = 512;

    let socket = null;
    let sessionId = null;
    const pressedKeys = new Set();
    const mouseDelta = { dx: 0, dy: 0 };
    let animationToken = null;
    const demoImages = {};
    let selectedImagePath = "";
    let mouseEnabled = true;
    const keyHistory = [];
    const inputEvents = [];

    const modeSelect = document.getElementById("mode");
    const imageInput = document.getElementById("image");
    const gallery = document.getElementById("imageGallery");
    const preview = document.getElementById("imagePreview");
    const streamFrame = document.getElementById("streamFrame");
    const streamMeta = document.getElementById("streamMeta");
    const logView = document.getElementById("log");

    const connectBtn = document.getElementById("connect");
    const setupBtn = document.getElementById("setup");
    const generateBtn = document.getElementById("generate");
    const resetBtn = document.getElementById("reset");

    const log = (...args) => {
      logView.textContent += args.join(" ") + "\n";
      logView.scrollTop = logView.scrollHeight;
    };

    const rememberKey = (code) => {
      const existing = keyHistory.indexOf(code);
      if (existing !== -1) {
        keyHistory.splice(existing, 1);
      }
      keyHistory.push(code);
    };

    const forgetKey = (code) => {
      const existing = keyHistory.indexOf(code);
      if (existing !== -1) {
        keyHistory.splice(existing, 1);
      }
    };

    const resolveAction = (mapping) => {
      for (let idx = keyHistory.length - 1; idx >= 0; idx -= 1) {
        const code = keyHistory[idx];
        if (!pressedKeys.has(code)) {
          continue;
        }
        const action = mapping[code];
        if (action) {
          return action;
        }
      }
      return "nomove";
    };

    const currentMovementAction = () => resolveAction(MOVEMENT_KEYS);
    const currentCameraAction = () => resolveAction(CAMERA_KEYS);

    const enqueueInputEvent = (payload) => {
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        return;
      }
      const stamp = typeof performance !== "undefined" ? performance.now() : Date.now();
      inputEvents.push({ ...payload, timestamp: stamp });
      const overflow = inputEvents.length - MAX_EVENT_QUEUE;
      if (overflow > 0) {
        inputEvents.splice(0, overflow);
      }
    };

    const refreshMouseMode = () => {
      mouseEnabled = MODE_MOUSE[modeSelect.value] ?? true;
    };

    const mappedKeys = () => {
      const mapping = KEY_MAP[modeSelect.value] || {};
      return Array.from(pressedKeys)
        .map(code => mapping[code])
        .filter(Boolean);
    };

    const normalisePathForPreview = (path) => path.replace(/^Matrix-Game-2\//, "");

    const updatePreview = (path) => {
      if (!path) {
        preview.style.display = "none";
        preview.removeAttribute("src");
        return;
      }
      preview.src = normalisePathForPreview(path);
      preview.style.display = "block";
    };

    const highlightSelection = () => {
      const buttons = gallery.querySelectorAll("button");
      buttons.forEach(btn => {
        if (btn.dataset.path === selectedImagePath) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });
    };

    const renderGallery = () => {
      const mode = modeSelect.value;
      const images = demoImages[mode] || [];
      if (!images.includes(selectedImagePath)) {
        selectedImagePath = images[0] || "";
      }
      gallery.innerHTML = "";
      images.forEach(path => {
        const button = document.createElement("button");
        button.type = "button";
        button.dataset.path = path;
        const img = document.createElement("img");
        img.src = normalisePathForPreview(path);
        img.alt = `${mode} ${path.split("/").pop()}`;
        button.appendChild(img);
        button.addEventListener("click", () => {
          selectedImagePath = path;
          imageInput.value = path;
          updatePreview(path);
          highlightSelection();
        });
        gallery.appendChild(button);
      });
      highlightSelection();
      if (selectedImagePath && !imageInput.value) {
        imageInput.value = selectedImagePath;
      }
      updatePreview(imageInput.value);
    };

    const updateStreamFrame = (msg) => {
      streamFrame.src = `data:image/${msg.format || "jpeg"};base64,${msg.image}`;
      streamFrame.style.display = "block";
      const index = (msg.index ?? 0) + 1;
      streamMeta.textContent = `Frame ${index}/${msg.total || "?"} · ${msg.width || "?"}×${msg.height || "?"}`;
    };

    const resetStreamDisplay = () => {
      streamMeta.textContent = "";
      streamFrame.style.display = "none";
      streamFrame.removeAttribute("src");
    };

    const isTypingTarget = (event) => {
      const tag = event.target.tagName;
      return tag === "INPUT" || tag === "SELECT" || tag === "TEXTAREA";
    };

    const pumpActions = () => {
      if (!socket || socket.readyState !== WebSocket.OPEN || !sessionId) {
        animationToken = requestAnimationFrame(pumpActions);
        return;
      }
      const keyboardState = mappedKeys();
      const movementAction = currentMovementAction();
      const cameraAction = currentCameraAction();
      const pendingEvents = inputEvents.length ? inputEvents.splice(0, inputEvents.length) : null;
      const payload = {
        type: "action",
        keyboard: {
          state: keyboardState,
          raw: Array.from(pressedKeys),
          movement: movementAction,
          camera: cameraAction,
        },
        repeat: 1
      };
      if (mouseEnabled) {
        payload.mouse = { dx: mouseDelta.dx, dy: mouseDelta.dy };
      }
      if (pendingEvents && pendingEvents.length) {
        payload.events = pendingEvents;
      }
      socket.send(JSON.stringify(payload));
      mouseDelta.dx = 0;
      mouseDelta.dy = 0;
      animationToken = requestAnimationFrame(pumpActions);
    };

    modeSelect.addEventListener("change", () => {
      refreshMouseMode();
      renderGallery();
    });

    imageInput.addEventListener("change", () => {
      const value = imageInput.value.trim();
      selectedImagePath = value;
      updatePreview(value);
      highlightSelection();
    });

    const hostInput = document.getElementById("host");
    const portInput = document.getElementById("port");

    connectBtn.addEventListener("click", () => {
      if (socket) {
        socket.close();
        return;
      }
      const host = hostInput.value;
      const port = portInput.value;
      socket = new WebSocket(`http://${host}:${port}/ws`);
      socket.onopen = () => {
        log("Connected.");
        connectBtn.textContent = "Disconnect";
        setupBtn.disabled = false;
        animationToken = requestAnimationFrame(pumpActions);
      };
      socket.onclose = () => {
        log("Connection closed.");
        connectBtn.textContent = "Connect";
        setupBtn.disabled = true;
        generateBtn.disabled = true;
        resetBtn.disabled = true;
        sessionId = null;
        socket = null;
        if (animationToken) cancelAnimationFrame(animationToken);
        animationToken = null;
        pressedKeys.clear();
        keyHistory.length = 0;
        inputEvents.length = 0;
        mouseDelta.dx = 0;
        mouseDelta.dy = 0;
        resetStreamDisplay();
      };
      socket.onerror = (event) => {
        log("Socket error:", event);
      };
      socket.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        if (msg.type === "ready") {
          log(`Server ready. Modes: ${msg.modes.join(", ")}.`);
          Object.assign(demoImages, msg.demo_images || {});
          renderGallery();
        } else if (msg.type === "session_started") {
          sessionId = msg.session_id;
          generateBtn.disabled = false;
          resetBtn.disabled = false;
          log(`Session ${sessionId} started in mode ${msg.mode}.`);
        } else if (msg.type === "action_ack") {
          if (msg.buffer_full) {
            log(`Buffer full after ${msg.frames_recorded} frames.`);
          }
        } else if (msg.type === "frame") {
          updateStreamFrame(msg);
        } else if (msg.type === "generation_complete") {
          log(`Generation complete. Frames: ${msg.total_frames || "?"}. Video: ${msg.video_path}`);
        } else if (msg.type === "session_reset") {
          log("Session buffer reset.");
          resetStreamDisplay();
        } else if (msg.type === "error") {
          log(`Error [${msg.error.code}]: ${msg.error.message}`);
        }
      };
    });

    setupBtn.addEventListener("click", () => {
      if (!socket) return;
      const imagePath = imageInput.value.trim() || selectedImagePath;
      if (!imagePath) {
        log("Provide an image path the server can read.");
        return;
      }
      const mode = modeSelect.value;
      socket.send(JSON.stringify({ type: "setup", image_path: imagePath, mode }));
    });

    generateBtn.addEventListener("click", () => {
      if (socket && sessionId) {
        resetStreamDisplay();
        socket.send(JSON.stringify({ type: "generate", session_id: sessionId }));
      }
    });

    resetBtn.addEventListener("click", () => {
      if (socket && sessionId) {
        socket.send(JSON.stringify({ type: "reset", session_id: sessionId }));
        resetStreamDisplay();
      }
    });

    document.addEventListener("keydown", (event) => {
      if (isTypingTarget(event)) return;
      if (event.repeat) return;
      pressedKeys.add(event.code);
      rememberKey(event.code);
      enqueueInputEvent({
        kind: "keyboard",
        phase: "press",
        code: event.code,
        key: event.key || "",
        movement: MOVEMENT_KEYS[event.code] || null,
        camera: CAMERA_KEYS[event.code] || null,
        modifiers: {
          altKey: event.altKey,
          ctrlKey: event.ctrlKey,
          metaKey: event.metaKey,
          shiftKey: event.shiftKey,
        },
      });
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(event.code)) {
        event.preventDefault();
      }
    });

    document.addEventListener("keyup", (event) => {
      if (isTypingTarget(event)) return;
      pressedKeys.delete(event.code);
      forgetKey(event.code);
      enqueueInputEvent({
        kind: "keyboard",
        phase: "release",
        code: event.code,
        key: event.key || "",
        movement: MOVEMENT_KEYS[event.code] || null,
        camera: CAMERA_KEYS[event.code] || null,
        modifiers: {
          altKey: event.altKey,
          ctrlKey: event.ctrlKey,
          metaKey: event.metaKey,
          shiftKey: event.shiftKey,
        },
      });
    });

    document.addEventListener("mousedown", (event) => {
      enqueueInputEvent({
        kind: "mouse",
        phase: "press",
        button: event.button,
        buttons: event.buttons,
        clientX: event.clientX,
        clientY: event.clientY,
      });
    });

    document.addEventListener("mouseup", (event) => {
      enqueueInputEvent({
        kind: "mouse",
        phase: "release",
        button: event.button,
        buttons: event.buttons,
        clientX: event.clientX,
        clientY: event.clientY,
      });
    });

    document.addEventListener("wheel", (event) => {
      enqueueInputEvent({
        kind: "mouse",
        phase: "wheel",
        deltaX: event.deltaX,
        deltaY: event.deltaY,
        deltaMode: event.deltaMode,
        clientX: event.clientX,
        clientY: event.clientY,
      });
    }, { passive: true });

    document.addEventListener("mousemove", (event) => {
      if (event.movementX !== 0 || event.movementY !== 0) {
        enqueueInputEvent({
          kind: "mouse",
          phase: "move",
          dx: event.movementX,
          dy: event.movementY,
          buttons: event.buttons,
          clientX: event.clientX,
          clientY: event.clientY,
        });
      }
      if (!mouseEnabled) return;
      mouseDelta.dx += event.movementX / 120;
      mouseDelta.dy += -event.movementY / 120;
    });

    refreshMouseMode();
    renderGallery();

    window.addEventListener("blur", () => {
      pressedKeys.clear();
      keyHistory.length = 0;
    });
  </script>
</body>
</html>
